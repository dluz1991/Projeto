package CodeGenerator;

import java.io.*;
import java.util.*;

import Calc.*;
import VM.OpCode;
import VM.Instruction.*;

public class CodeGen extends CalcBaseVisitor<Void> {

    // the target code
    private final ArrayList<Instruction> code = new ArrayList<>();

    @Override public Void visitProg(CalcParser.ProgContext ctx) { return visitChildren(ctx); }

    @Override public Void visitStat(CalcParser.StatContext ctx) {
        visit(ctx.expr());
        emit(OpCode.iprint);
        return null;
    }

    @Override public Void visitOr(CalcParser.OrContext ctx) { return visitChildren(ctx); }

    @Override public Void visitBool(CalcParser.BoolContext ctx) { return visitChildren(ctx); }

    @Override public Void visitMulDiv(CalcParser.MulDivContext ctx) {
        visit(ctx.expr(0));
        visit(ctx.expr(1));
        if ("*".equals(ctx.op.getText())) emit(OpCode.imult);
        else // must be /
            emit(OpCode.idiv);
        return null; }

    @Override public Void visitAddSub(CalcParser.AddSubContext ctx) { return visitChildren(ctx); }

    @Override public Void visitParens(CalcParser.ParensContext ctx) { return visitChildren(ctx); }

    @Override public Void visitAnd(CalcParser.AndContext ctx) { return visitChildren(ctx); }

    @Override public Void visitReal(CalcParser.RealContext ctx) { return visitChildren(ctx); }

    @Override public Void visitRelational(CalcParser.RelationalContext ctx) { return visitChildren(ctx); }

    @Override public Void visitString(CalcParser.StringContext ctx) { return visitChildren(ctx); }

    @Override public Void visitUnary(CalcParser.UnaryContext ctx) {
        visit(ctx.expr());
        emit(OpCode.iuminus);
        return null;
    }

    @Override public Void visitInt(CalcParser.IntContext ctx) { return visitChildren(ctx); }
    
   /*
        Utility functions
    */

    public void emit(OpCode opc) {
        code.add(new Instruction(opc));
    }

    public void emit(OpCode opc, int val) {
        code.add(new Instruction1Arg(opc, val));
    }

    // dump the code to the screen in "assembly" format
    public void dumpCode() {
        System.out.println("Generated code in assembly format");
        for (int i = 0; i < code.size(); i++)
            System.out.println(i + ": " + code.get(i));
    }

    // save the generated bytecodes to file filename
    public void saveBytecodes(String filename) throws IOException {
        try (DataOutputStream dout = new DataOutputStream(new FileOutputStream(filename))) {
            for (Instruction inst : code)   // the instructions
                inst.writeTo(dout);
            System.out.println("Saving the bytecodes to " + filename);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

}
